{"meta":{"title":"Ciscosq","subtitle":"","description":"","author":"ciscosq","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2020-03-06T10:16:42.253Z","updated":"2020-03-06T10:16:42.253Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"单双长按键","date":"2020-03-24T13:36:24.000Z","updated":"2020-03-24T13:37:26.021Z","comments":true,"path":"cisconsq/单双长按键.html","permalink":"http://yoursite.com/cisconsq/%E5%8D%95%E5%8F%8C%E9%95%BF%E6%8C%89%E9%94%AE.html","excerpt":"","text":"题目：多功能按键设计。利用一个I/O口，接一个按键，实现3功能操作：单击 + 双击 + 长按。 用户基本操作定义： 1。短按操作：按键按下，按下时间&lt;1s，属于一次短按操作 2。长按操作：按键按下，按下时间&gt;1s，属于一次长按操作 在正常0.5s内无按键操作为启始按键扫描条件下，扫描按键将产生以下3种按键事件： 1。长按事件：任何1次出现的长按操作都属于长按事件 2。单击事件：1次短按操作后，间隔0.5内没有短按操作 3。双击事件：2次短按操作间隔时间&lt;0.5s，则2次短按操作为1次双击事件，且2次短按都取消 特别操作情况定义： 1。短按操作和长按操作间隔&lt;0.5s，以及，长按操作和短按操作间隔&lt;0.5s，均不产生双击事件 2。连续n次（n为奇数）短按操作，且间隔均&lt;0.5s，产生(n-1)/2次双击事件+1次单击事件 3。连续n次（n为偶数）短按操作，且间隔均&lt;0.5s，产生n/2次双击事件 对按键操作者的建议： 由于按键的多功能性质，建议操作者每次在单击/长按/双击按键事件发生后，隔0.5s后再进行下一次的按键操作。因为在特别操作情况下，程序是保证按定义进行判断和处理的，主要是怕操作者自己记不清楚导致操作失误。 对软件设计者的要求： 1。应该全面进行分析，给出严格定义和判断条件，如上所示。如果自己都不清楚，你的设计出的系统就不稳定，不可靠。 2。在1的基础上，编写出符合要求的程序，并进行全面测试。 /=============低层按键（I/0）扫描函数，即低层按键设备驱动，只返回无键、短按和长按。具体双击不在此处判断。参考本人教材的例9-1，稍微有变化。教材中为连_发。===============/ #define key_input PIND.7 // 按键输入口 #define N_key 0 //无键#define S_key 1 //单键#define D_key 2 //双键#define L_key 3 //长键 #define key_state_0 0#define key_state_1 1#define key_state_2 2 unsigned char key_driver(void){ static unsigned char key_state = key_state_0, key_time = 0; unsigned char key_press, key_return = N_key; key_press = key_input; // 读按键I/O电平 switch (key_state) { case key_state_0: // 按键初始态 if (!key_press) key_state = key_state_1; // 键被按下，状态转换到按键消抖和确认状态 break; case key_state_1: // 按键消抖与确认态 if (!key_press) { key_time = 0; // key_state = key_state_2; // 按键仍然处于按下，消抖完成，状态转换到按下键时间的计时状态，但返回的还是无键事件 } else key_state = key_state_0; // 按键已抬起，转换到按键初始态。此处完成和实现软件消抖，其实按键的按下和释放都在此消抖的。 break; case key_state_2: if(key_press) { key_return = S_key; // 此时按键释放，说明是产生一次短操作，回送S_key key_state = key_state_0; // 转换到按键初始态 } else if (++key_time &gt;= 100) // 继续按下，计时加10ms（10ms为本函数循环执行间隔） { key_return = L_key; // 按下时间&gt;1000ms，此按键为长按操作，返回长键事件 key_state = key_state_3; // 转换到等待按键释放状态 } break;​ case key_state_3: // 等待按键释放状态，此状态只返回无按键事件​ if (key_press) key_state = key_state_0; //按键已释放，转换到按键初始态​ break; } return key_return;} /=============中间层按键处理函数，调用低层函数一次，处理双击事件的判断，返回上层正确的无键、单键、双键、长键4个按键事件。本函数由上层循环调用，间隔10ms===============/ unsigned char key_read(void){ static unsigned char key_m = key_state_0, key_time_1 = 0; unsigned char key_return = N_key,key_temp; key_temp = key_driver(); switch(key_m) { case key_state_0: if (key_temp == S_key ) { key_time_1 = 0; // 第1次单击，不返回，到下个状态判断后面是否出现双击 key_m = key_state_1; } else key_return = key_temp; // 对于无键、长键，返回原事件 break; ​ case key_state_1:​ if (key_temp == S_key) // 又一次单击（间隔肯定&lt;500ms）​ {​ key_return = D_key; // 返回双击键事件，回初始状态​ key_m = key_state_0;​ }​ else​ { // 这里500ms内肯定读到的都是无键事件，因为长键&gt;1000ms，在1s前低层返回的都是无键​ if(++key_time_1 &gt;= 50)​ {​ key_return = S_key; // 500ms内没有再次出现单键事件，返回上一次的单键事件​ key_m = key_state_0; // 返回初始状态​ }​ }​ break; } return key_return;} 下面，根据程序分析按键事件的反映时间：1。对于长键，按下超过1s马上响应，反映最快2。对于双键，第2次按键释放后马上得到反映。3。对于单键，释放后延时拖后500ms才能响应，反映最慢。这个与需要判断后面是否有双击操作有关，只能这样。实际应用中，可以调整两次单击间隔时间定义，比如为300ms，这样单击的响应回快一点，单按键操作人员需要加快按键的操作过程。如果产品是针对老年人的，这个时间不易太短，因为年纪大的人，反映和动作都比较慢。 当然，上面两段可以合在一起。我这样做的目的，是为了可以方便的扩展为N击（当然，需要做修改）。可是最底层的就是最基本的操作处理短按和长按，不用改动的。至于双击，还是N击，在中间层处理。这就是程序设计中分层结构的优点。 测试代码环境如下： interrupt [TIM0_COMP] void timer0_comp_isr(void) // 定时器10ms中断服务{ time_10ms_ok = 1;} main(viod){ ……… while { if (time_10ms_ok) //每10ms执行一次， { time_10ms_ok =0; key = key_read(); //《====== 10ms一次调用按键中间层函数，根据返回键值，点亮不同的LED灯，全面测试按键操作是否正常 if (key == L_key) ……..//点亮A_LED，关闭B_LED和C_LED else if(key == D_key) ……..//点亮B_LED，关闭A_LED和C_LED else if(key == S_key) ……..//点亮C_LED，关闭A_LED和B_LED } }} ================================================= 通过以上这个看似简单的按键，看在应用中如何变化，以及如何在实际产品中全面、可靠的进行设计。后续： 这个是一个网友要求我做的东西，他买了我编写的教材，学习了里面的状态机按键设计，但还是不能灵活的使用。我提出让一些有兴趣的朋友做一下，大家讨论，（见http://www.ourdev.cn/bbs/bbs_content.jsp?bbs_sn=4971785&amp;bbs_page_no=1&amp;bbs_id=1003，28楼），但是很少人给出满意的回答。甚至是这样的回答：“晕，参加电设的也有很多强人，虽然不一定是精英，但还是很有实力的，这种题目很多人都很早就会做了，没必要当作电设的训练题。（见该贴30楼的回答）”。 这个如同我去年挑战一个北大高才生一样，真本事没有，就是嘴硬。 既然别人不感“兴趣”，我编写代码，实现这个简单的多功能按键。这也是对这位购买我编写书的朋友的一种答谢吧。 写完后，还想扩展一点，发点“偏见”如下： 相比国际上的一些品牌产品，国内的很多东西都做不精。其中系统分析和软件设计占有重要的因素。其实不是不想做的好，而是根本没有能力做好！ 如上这样一个简单的多功能按键，都分析不透，设计不出好的代码，就不要谈上天下海的吧。D车追尾就是发生了特殊情况，设计中根本没有考虑周全，加上工作人员的不负责，产生如此大的灾难。 最近频繁出现的塌桥、电梯事故、火车出事，都是上天对现在浮躁社会的报应。我们都抱怨别人不负责，浮躁，那么你自己呢？ 别人，别的行业我没有资格讲不好，但是对于正在学习的本专业大学生，尤其是要参加全国大学生电子设计大赛的学生，你做这个题目能拿多少分？评估一下有多少能力和水平？ 实际上，现在的全国大学生电子设计大赛也变成是一个浮躁的产物，学校和学生都指望它能贴金，对于真正培养和锻炼人的目的和作用，实际上只是挂在前面遮羞布了。"},{"title":"仅三行按键程序","date":"2020-03-24T13:27:27.000Z","updated":"2020-03-24T13:28:10.740Z","comments":true,"path":"cisconsq/仅三行按键程序.html","permalink":"http://yoursite.com/cisconsq/%E4%BB%85%E4%B8%89%E8%A1%8C%E6%8C%89%E9%94%AE%E7%A8%8B%E5%BA%8F.html","excerpt":"","text":"新型的按键扫描程序不过我在网上游逛了很久，也看过不少源程序了，没有发现这种按键处理办法的踪迹，所以，我将他共享出来，和广大同僚们共勉。我非常坚信这种按键处理办法的便捷和高效，你可以移植到任何一种嵌入式处理器上面，因为C语言强大的可移植性。同时，这里面用到了一些分层的思想，在单片机当中也是相当有用的，也是本文的另外一个重点。对于老鸟，我建议直接看那两个表达式，然后自己想想就会懂的了，也不需要听我后面的自吹自擂了，我可没有班门弄斧的意思，hoho～～但是对于新手，我建议将全文看完。因为这是实际项目中总结出来的经验，学校里面学不到的东西。以下假设你懂C语言，因为纯粹的C语言描述，所以和处理器平台无关，你可以在MCS-51，AVR，PIC，甚至是ARM平台上面测试这个程序性能。当然，我自己也是在多个项目用过，效果非常好的。好了，工程人员的习惯，废话就应该少说，开始吧。以下我以AVR的MEGA8作为平台讲解，没有其它原因，因为我手头上只有AVR的板子而已没有51的。用51也可以，只是芯片初始化部分不同，还有寄存器名字不同而已。核心算法：unsigned char Trg;unsigned char Cont;void KeyRead( void ){ unsigned char ReadData = PINB^0xff; // 1 Trg = ReadData &amp; (ReadData ^ Cont); // 2 Cont = ReadData; // 3}完了。有没有一种不可思议的感觉？当然，没有想懂之前会那样，想懂之后就会惊叹于这算法的精妙！！下面是程序解释：Trg（triger） 代表的是触发，Cont（continue）代表的是连续按下。1：读PORTB的端口数据，取反，然后送到ReadData 临时变量里面保存起来。2：算法1，用来计算触发变量的。一个位与操作，一个异或操作，我想学过C语言都应该懂吧？Trg为全局变量，其它程序可以直接引用。3：算法2，用来计算连续变量。看到这里，有种“知其然，不知其所以然”的感觉吧？代码很简单，但是它到底是怎么样实现我们的目的的呢？好，下面就让我们绕开云雾看青天吧。我们最常用的按键接法如下：AVR是有内部上拉功能的，但是为了说明问题，我是特意用外部上拉电阻。那么，按键没有按下的时候，读端口数据为1，如果按键按下，那么端口读到0。下面就看看具体几种情况之下，这算法是怎么一回事。（1） 没有按键的时候端口为0xff，ReadData读端口并且取反，很显然，就是 0x00 了。Trg = ReadData &amp; (ReadData ^ Cont); （初始状态下，Cont也是为0的）很简单的数学计算，因为ReadData为0，则它和任何数“相与”，结果也是为0的。Cont = ReadData; 保存Cont 其实就是等于ReadData，为0；结果就是：ReadData ＝ 0；Trg ＝ 0；Cont ＝ 0；（2） 第一次PB0按下的情况端口数据为0xfe，ReadData读端口并且取反，很显然，就是 0x01 了。Trg = ReadData &amp; (ReadData ^ Cont); 因为这是第一次按下，所以Cont是上次的值，应为为0。那么这个式子的值也不难算，也就是 Trg = 0x01 &amp; (0x01^0x00) = 0x01Cont = ReadData = 0x01；结果就是：ReadData ＝ 0x01；Trg ＝ 0x01；Trg只会在这个时候对应位的值为1，其它时候都为0Cont ＝ 0x01；（3） PB0按着不松（长按键）的情况端口数据为0xfe，ReadData读端口并且取反是 0x01 了。Trg = ReadData &amp; (ReadData ^ Cont); 因为这是连续按下，所以Cont是上次的值，应为为0x01。那么这个式子就变成了 Trg = 0x01 &amp; (0x01^0x01) = 0x00Cont = ReadData = 0x01；结果就是：ReadData ＝ 0x01；Trg ＝ 0x00；Cont ＝ 0x01；因为现在按键是长按着，所以MCU会每个一定时间（20ms左右）不断的执行这个函数，那么下次执行的时候情况会是怎么样的呢？ReadData ＝ 0x01；这个不会变，因为按键没有松开Trg ＝ ReadData &amp; (ReadData ^ Cont) ＝ 0x01 &amp; (0x01 ^ 0x01) = 0 ，只要按键没有松开，这个Trg值永远为 0 ！！！Cont ＝ 0x01；只要按键没有松开，这个值永远是0x01！！（4） 按键松开的情况端口数据为0xff，ReadData读端口并且取反是 0x00 了。Trg = ReadData &amp; (ReadData ^ Cont) = 0x00 &amp; (0x00^0x01) = 0x00Cont = ReadData = 0x00；结果就是：ReadData ＝ 0x00；Trg ＝ 0x00；Cont ＝ 0x00；很显然，这个回到了初始状态，也就是没有按键按下的状态。总结一下，不知道想懂了没有？其实很简单，答案如下：Trg 表示的就是触发的意思，也就是跳变，只要有按键按下（电平从1到0的跳变），那么Trg在对应按键的位上面会置一，我们用了PB0则Trg的值为0x01，类似，如果我们PB7按下的话，Trg 的值就应该为 0x80 ，这个很好理解，还有，最关键的地方，Trg 的值每次按下只会出现一次，然后立刻被清除，完全不需要人工去干预。所以按键功能处理程序不会重复执行，省下了一大堆的条件判断，这个可是精粹哦！！Cont代表的是长按键，如果PB0按着不放，那么Cont的值就为 0x01，相对应，PB7按着不放，那么Cont的值应该为0x80，同样很好理解。如果还是想不懂的话，可以自己演算一下那两个表达式，应该不难理解的。因为有了这个支持，那么按键处理就变得很爽了，下面看应用：应用一：一次触发的按键处理假设PB0为蜂鸣器按键，按一下，蜂鸣器beep的响一声。这个很简单，但是大家以前是怎么做的呢？对比一下看谁的方便？#define KEY_BEEP 0x01void KeyProc(void){ if (Trg &amp; KEY_BEEP) // 如果按下的是KEY_BEEP { Beep(); // 执行蜂鸣器处理函数 }}怎么样？够和谐不？记得前面解释说Trg的精粹是什么？精粹就是只会出现一次。所以你按下按键的话，Trg &amp; KEY_BEEP 为“真”的情况只会出现一次，所以处理起来非常的方便，蜂鸣器也不会没事乱叫，hoho～～～或者你会认为这个处理简单，没有问题，我们继续。应用2：长按键的处理项目中经常会遇到一些要求，例如：一个按键如果短按一下执行功能A，如果长按2秒不放的话会执行功能B，又或者是要求3秒按着不放，计数连加什么什么的功能，很实际。不知道大家以前是怎么做的呢？我承认以前做的很郁闷。但是看我们这里怎么处理吧，或许你会大吃一惊，原来程序可以这么简单这里具个简单例子，为了只是说明原理，PB0是模式按键，短按则切换模式，PB1就是加，如果长按的话则连加（玩过电子表吧？没错，就是那个！）#define KEY_MODE 0x01 // 模式按键#define KEY_PLUS 0x02 // 加void KeyProc(void){ if (Trg &amp; KEY_MODE) // 如果按下的是KEY_MODE，而且你常按这按键也没有用， { //它是不会执行第二次的哦 ， 必须先松开再按下 Mode++; // 模式寄存器加1，当然，这里只是演示，你可以执行你想 // 执行的任何代码 } if (Cont &amp; KEY_PLUS) // 如果“加”按键被按着不放 { cnt_plus++; // 计时 if (cnt_plus &gt; 100) // 20ms*100 = 2S 如果时间到 { Func(); // 你需要的执行的程序 } }}不知道各位感觉如何？我觉得还是挺简单的完成了任务，当然，作为演示用代码。应用3：点触型按键和开关型按键的混合使用点触形按键估计用的最多，特别是单片机。开关型其实也很常见，例如家里的电灯，那些按下就不松开，除非关。这是两种按键形式的处理原理也没啥特别，但是你有没有想过，如果一个系统里面这两种按键是怎么处理的？我想起了我以前的处理，分开两个非常类似的处理程序，现在看起来真的是笨的不行了，但是也没有办法啊，结构决定了程序。不过现在好了，用上面介绍的办法，很轻松就可以搞定。原理么？可能你也会想到，对于点触开关，按照上面的办法处理一次按下和长按，对于开关型，我们只需要处理Cont就OK了，为什么？很简单嘛，把它当成是一个长按键，这样就找到了共同点，屏蔽了所有的细节。程序就不给了，完全就是应用2的内容，在这里提为了就是说明原理～～好了，这个好用的按键处理算是说完了。可能会有朋友会问，为什么不说延时消抖问题？哈哈，被看穿了。果然不能偷懒。下面谈谈这个问题，顺便也就非常简单的谈谈我自己用时间片轮办法，以及是如何消抖的。延时消抖的办法是非常传统，也就是 第一次判断有按键，延时一定的时间（一般习惯是20ms）再读端口，如果两次读到的数据一样，说明了是真正的按键，而不是抖动，则进入按键处理程序。当然，不要跟我说你delay（20）那样去死循环去，真是那样的话，我衷心的建议你先放下手上所有的东西，好好的去了解一下操作系统的分时工作原理，大概知道思想就可以，不需要详细看原理，否则你永远逃不出“菜鸟”这个圈子。当然我也是菜鸟。我的意思是，真正的单片机入门，是从学会处理多任务开始的，这个也是学校程序跟公司程序的最大差别。当然，本文不是专门说这个的，所以也不献丑了。我的主程序架构是这样的：volatile unsigned char Intrcnt;void InterruptHandle() // 中断服务程序{ Intrcnt++; // 1ms 中断1次，可变}void main(void){ SysInit(); while(1) // 每20ms 执行一次大循环 { KeyRead(); // 将每个子程序都扫描一遍 KeyProc(); Func1(); Funt2(); … … while(1) { if (Intrcnt&gt;20) // 一直在等，直到20ms时间到 { Intrcnt=”0”; break; // 返回主循环 } } }}貌似扯远了，回到我们刚才的问题，也就是怎么做按键消抖处理。我们将读按键的程序放在了主循环，也就是说，每20ms我们会执行一次KeyRead()函数来得到新的Trg 和 Cont 值。好了，下面是我的消抖部分：很简单基本架构如上，我自己比较喜欢的，一直在用。当然，和这个配合，每个子程序必须执行时间不长，更加不能死循环，一般采用有限状态机的办法来实现，具体参考其它资料咯。懂得基本原理之后，至于怎么用就大家慢慢思考了，我想也难不到聪明的工程师们。例如还有一些处理，怎么判断按键释放？很简单，Trg 和Cont都为0 则肯定已经释放了。"},{"title":"分类","date":"2020-03-06T10:16:25.454Z","updated":"2020-03-06T10:16:25.454Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo博客系列操作","slug":"Hexo系列操作","date":"2020-03-06T10:21:39.000Z","updated":"2020-03-23T15:39:13.348Z","comments":true,"path":"2020/03/06/Hexo系列操作/","link":"","permalink":"http://yoursite.com/2020/03/06/Hexo%E7%B3%BB%E5%88%97%E6%93%8D%E4%BD%9C/","excerpt":"本文将讲述搭建博客以及编写博文一系列步骤。","text":"本文将讲述搭建博客以及编写博文一系列步骤。 文章会不定时进行更新，不过我比较懒呐~但是很高兴你阅读我的博文。 文章可能会涉及有关参考资料、教程、链接如有侵权请联系我删除！ 【01】博客搭建 安装必备软件 Node.js (https://nodejs.org/en/) git (https://git-scm.com/downloads) 摸个鱼，双手奉上大佬安装视频 (https://www.bilibili.com/video/av44544186) 【02】博客绑定个人域名俺是一块砖，哪里需要哪里搬 首先购买个人域名（阿里云、腾讯云、花生壳等都行）腾讯云：[腾讯云网址]:https://cloud.tencent.com/act/campus?fromSource=gwzcw.2736595.2736595.2736595&amp;utm_medium=cpc&amp;utm_id=gwzcw.2736595.2736595.2736595 域名购买成功后，在windows下cmd里ping一下自己的博客就会得到ip地址（这个地址后续需用到）;接着回到腾讯云首页点控制台-&gt;域名管理进入,点击解析，填写得到的IP地址到记录值一栏，就ok了。如下图所示： 最后，在本地hexo文件夹中，找到source文件夹并在里面创建CNAME文件（没有后缀名），在里面写上购买的域名。比如：&emsp;接着登入GitHub，打开自己项目仓库的（Settings）设置,然后在GitHub Pages的 Custom domain设置里填上购买的域名，完结撒花。 【03】博客插入图片三种法子，任君挑选 无存储式显示图片步骤：直接在网上右击将图片链接复制,在md文件中填写以下格式。格式：&nbsp;![ ]&nbsp;(填写图片链接)&nbsp; 本地存储显示图片步骤： 修改博客中根目录中 _config.yml 文件配置项 post_asset_folder 为 true 完成设置后, 在本地博客文件夹中找到自己所建md文件,并新建一个与md文件名字相同的文件夹，用来存放图片。 在Git Bash Here敲写如下代码1npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save 最后一步,将需要添加得图片放入同名的文件夹里，同时通过相对路径索引到该图片。格式： 同 无存储式显示图片一样 仓库存储显示图片步骤： 在GitHub上新建一个存放图片的仓库（这个一开始很麻烦后来就很轻松）GitHub：[github]:https://github.com/ 先从创建仓库开始,点击如图New后完成一些信息填写,完成新仓库的创建 找到下面图中 README 进行点击后，不必动.接着点击下张图中 Commit new file 最后点击上传后，如下图所示,接着就和 无存储式显示图片 一样步骤，就结束啦（撒花）","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/category/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tag/hexo/"}]}]}